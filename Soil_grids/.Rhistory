pkgs <- readLines(file("http://www.uni-koblenz-landau.de/campus-landau/faculty7/environmental-sciences/landscape-ecology/Teaching/inst_pkgs/at_download/file", "r"))
str(pkgs)
install.packages(pkgs)
.libPaths()
library(sp)
0.9*0.9*0.9*0.9
library("simecol")#
CA <- new("gridModel",#
    main = function(time, init, parms) {#
      z     <- init #grid size#
      nb    <- eightneighbors(z) # gives the sum of the neighbors of a cell#
      pgen  <- 1 - (1 - parms$pbirth)^nb #
      # probability of birth of new cell, increases with nb#
      zgen  <- ifelse(z == 0 & #
                 runif(z) < pgen, 1, 0) #
      # if pgen > a random number from the uniform distribution #
      # between 1 and 0 and z is 0 before, than z turns to 1#
      zsurv <- ifelse(z >= 1 & #
                 runif(z) < (1 - parms$pdeath), #
                 z + 1, 0) #
       # if any of the z numbers drawn from the uniform distribution #
       # is > 1-parms$pdeath, then z is 0, else z increases by 1 (which#
       # indicates ageing#
      zgen + zsurv#
      # joins the grid for generated species and surviving species#
    },#
    parms = list(pbirth = 0.01, pdeath = 0.02),# model parameters#
    times = c(from = 1, to = 1000, by = 1),# time steps#
    init = matrix(0, nrow = 40, ncol = 40),# grid size#
    solver = "iteration"#
)
init(CA)[18:22,18:22] <- 1#set some cells to one - otherwise nothing will happen
result_CA <- sim(CA)
print(result_CA)
plot(result_CA)
CA2 <- new("gridModel",#
    main = function(time, init, parms) {#
      z     <- init #grid size#
      nb    <- eightneighbors(z) # gives the sum of the neighbors of a cell#
      pgen  <- 1 - (1 - parms$pbirth)^nb #
      # probability of birth of new cell, increases with nb#
      zgen  <- ifelse(z == 0 & #
                 runif(z) < pgen, 1, 0) #
      # if pgen > a random number from the uniform distribution #
      # between 1 and 0 and z is 0 before, than z turns to 1#
      zsurv <- ifelse(z >= 1 & #
                 runif(z) < (1 - parms$pdeath), #
                 z + 1, 0) #
       # if any of the z numbers drawn from the uniform distribution #
       # is > 1-parms$pdeath, then z is 0, else z increases by 1 (which#
       # indicates ageing#
      zgen + zsurv#
      # joins the grid for generated species and surviving species#
    },#
    parms = list(pbirth = 0.05, pdeath = 0.3),# model parameters#
    times = c(from = 1, to = 1000, by = 1),# time steps#
    init = matrix(0, nrow = 40, ncol = 40),# grid size#
    solver = "iteration"#
)
init(CA2)[18:22,18:22] <- 1#set some cells to one - otherwise nothing will happen#
#
result_CA2 <- sim(CA2)#
print(result_CA2)#
plot(result_CA2)
sum_ca <- lapply(result_CA@out, sum)#
values <- unlist(sum_ca)#
plot(values, type ="l")
sum_ca2 <- lapply(result_CA2@out, sum)#
values2 <- unlist(sum_ca2)#
plot(values/10, type ="l")#
lines(values2,  col = "red")#
# equilibrium decreases with higher mortality
0.6^2+0.8^2
matrix(c(8.2, -14.8, -1.8, -18.8, 27.2, 37.6, -29.4, -19.4, -22.4, 33.6), ncol=2) -° a
matrix(c(8.2, -14.8, -1.8, -18.8, 27.2, 37.6, -29.4, -19.4, -22.4, 33.6), ncol=2) -> a
a
vcov(a)
cov(a)
sd(a[ ,2])
sd(a[ ,2])^2
345.7*1071.30 - 528.35^2
1071.3+345.7
-1417/2 + sqrt((-1417/2)^2 - 91194.69)
1417/2 + sqrt((-1417/2)^2 - 91194.69)
1417/2 - sqrt((-1417/2)^2 - 91194.69)
library(polynom)
polynomial(c(91194.69,1417,1 ))
polynomial(c(91194.69,-1417,1 ))
p <- polynomial(c(91194.69,-1417,1 ))
solve(p)
predict(p, 300)
plot(p)
par(cex=1.2, las=1)
par(cex=1.3, las=1)
par(cex=1.4, las=1)
plot(p, axes=F)
plot(p, axes=F, lwd=1.4)
plot(p, axes=F, lwd=1.5)
plot(p, axes=F, lwd=1.5, xlab=expression("lambda"))
plot(p, axes=F, lwd=1.5, xlab=expression("%lambda"))
plot(p, axes=F, lwd=1.5, xlab=expression("Lambda"))
par(cex=1.5, las=1)
plot(p, axes=F, lwd=1.5, xlab=expression(lambda))
plot(p, axes=F, lwd=1.5, xlab=expression(lambda), ylab=expression(paste("F(", lambda, ")")))
axis(1, pos=0)
axis(2, pos=0)
par(cex=2.5, las=1)#
plot(p, axes=F, lwd=1.5, xlab=expression(lambda), ylab=expression(paste("F(", lambda, ")")))#
axis(1, pos=0)#
axis(2, pos=0)
par(cex=2, las=1)#
plot(p, axes=F, lwd=1.5, xlab=expression(lambda), ylab=expression(paste("F(", lambda, ")")))#
axis(1, pos=0)#
axis(2, pos=0)
text(700, - 5e+05,"expression(lambda)")
mtext(700, - 5e+05,"expression(lambda)")
mtext("expression(lambda)")
mtext("expression(lambda)", side=2)
mtext("expression(lambda)", side=1)
mtext(expression(lambda), side=1)
par(cex=2, las=1)#
plot(p, axes=F, lwd=1.5, xlab=expression(lambda), ylab=expression(paste("F(", lambda, ")")))#
axis(1, pos=0)#
axis(2, pos=0)#
mtext(expression(lambda), side=1)
par(cex=2, las=1)#
plot(p, axes=F, lwd=1.5, xlab="", ylab=expression(paste("F(", lambda, ")")))#
axis(1, pos=0)#
axis(2, pos=0)#
mtext(expression(lambda), side=1)
par(cex=2, las=1)#
plot(p, axes=F, lwd=1.5, xlab="", ylab=expression(paste("F(", lambda, ")")))#
axis(1, pos=0)#
axis(2, pos=0)#
mtext(expression(lambda), side=1, cex=2)
library(vegan)#
# the vegan package contains several functions #
# for multivariate analysis of ecological data#
# and represents a standard package#
data(varechem)#
head(varechem)#
# environmental
chisqplot.multi <- function(m, main="QQ plot", ylab=expression(paste(chi^2, " Quantile"))){#
  # n x p numeric matrix#
  x <- as.matrix(m)#
  # centroid#
  center <- colMeans(x) #
  n <- ncol(x)#
  cov <- cov(x)#
  # distances #
  d <- mahalanobis(x,center,cov) #
  s <- sort(d, index=TRUE)#
  q <- (0.5:length(d))/length(d)#
  par(las=1, cex=1.2)#
  plot(s$x, qchisq(q,df=n), main=main, xlab="Ordered Mahalanobis D2", ylab= ylab)#
  abline(a=0,b=1)#
}
chisqplot.multi(varechem)
(va_pca <- rda(varechem,scale=TRUE))#
# you should always scale unless the descriptors have the same order of magnitude#
summary(va_pca, display=NULL)
par(cex=1.5)#
plot(va_pca, display=c("sit"), type="text", scaling=1)
sum(apply(scale(varechem),2,var))
va_pca$CA$eig -> ev
sum(ev)
X.rpc <- princomp(varechem,cor = TRUE)
library(chemometrics)#
par(mfrow=c(1,2),cex=2)#
res <- pcaDiagplot(varechem, X.rpc,a =2, quantile=0.975)
which(res$ODist>4)
----------------------------------------------------------------------------
# install newest version of esmisc from github
library(devtools)
install_github('EDiLD/esmisc')
library(esmisc)
comp <- c("1-Chlor-2-nitrobenzol",#
         "1-Chlor-2,4-dinitrobenzol",#
         "1-Chlor-3-nitrobenzol",#
         "1-Chlor-4-nitrobenzol",#
         "1-Chlornaphthalin",#
         "1,1-Dichlorethan",#
         "1,1-Dichlorethen"#
)
etox_to_cas('2,4,5-Trichlorphenol')
cas <- sapply(comp, etox_to_cas)
df <- data.frame(comp, cas, row.names = NULL)
df
1350*8
166.7/13.74
?adonis
data(dune)#
data(dune.env)#
adonis(dune ~ Management*A1, data=dune.env, permutations=99)
data <- read.txt("~/Downloads/savedrecs.txt")
data
data <- read.csv("~/Downloads/savedrecs.txt")
text <- readLines("~/Downloads/savedrecs.txt")
text
grep("ER*")
grep("ER*", text)
grep("ER*", text, fixed=TRUE)
grep("ER", text, fixed=TRUE)
sub_er <- grep("ER", text, fixed=TRUE)
sub_er <- grep("ER", text, fixed=TRUE)#
sub_pt <- grep("PT", text, fixed=TRUE)#
sub_rp <- grep("RP", text, fixed=TRUE)#
sub_em <- grep("EM", text, fixed=TRUE)
sub <- text[ !(sub_er & sub_pt & sub_rp & sub_em), ]
sub <- text[ !(sub_er && sub_pt && sub_rp && sub_em), ]
sub <- text[ !(sub_er) & !( sub_pt ), ]
sub <- text[ !(sub_er) && !( sub_pt ), ]
(sub_er)
sub <- text[ !(sub_er), ]
sub <- text[ !(sub_er & sub_pt )  ]
sub <- text[ !(sub_er && sub_pt )  ]
sub <- text[ !(sub_er && sub_pt && sub_rp && sub_em)  ]
sub <- text[ !(sub_er) & ! (sub_pt) & ! (sub_rp) & ! (sub_em)  ]
sub <- text[ !(sub_er) & ! (sub_pt)  ]
sub <- text[ !(sub_er) && ! (sub_pt)  ]
sub <- text[ !(sub_er)  ]
str(text)
sub <- text[ -(sub_er)  ]
sub <- text[ -(sub_er) &  - (sub_rp)]
sub <- text[ -(sub_er) &&  - (sub_rp)]
sub_er & sub_rp
sub <- text[ -c(sub_er, sub_rp)]
sub <- text[ -c(sub_er, sub_rp, sub_em, sub_pt)]
sub
sub_ld <- grep("Landau", text, fixed=TRUE)
sub <- text[ -c(sub_er, sub_rp, sub_em, sub_pt, sub_ld)]
sub2
sub_at <- grep("@", text, fixed=TRUE)
sub <- text[ -c(sub_er, sub_rp, sub_em, sub_pt, sub_ld, sub_at)]
sort(nchar(sub))
sub2 <- sub[nchar(sub) > 6 ]
sub3 <- unique(sub2)
sub3
writeLines("~/Downloads/coop.txt")
writeLines(sub3, "~/Downloads/coop.txt")
27*0.37/500
0.6*6+0.4*2.3
0.6*5+0.4*2.3
file_pos <- file.choose()#
abbau <- read.csv(file_pos, sep=";", dec=",")[-25,]
file_pos1 <- file.choose()
grad <- read.csv(file_pos1, sep=";", dec=",")[-25,]# omit U32
mean(abbau$DD/abbau$DD_mi)
abbau$DD/abbau$DD_mi
mean(abbau$DD/(abbau$DD_mi+abbau$DD))
library(car)#
library(vegan)#
library(BiodiversityR)#
require(vegan)#
require(BiodiversityR)
abbau <- read.csv("~/Literatur/Publications/2015/Katha_2/Data_R/totalData.csvfile_pos", sep=";", dec=",")[-25,]# omit U32 does not fulfill
abbau <- read.csv("~/Literatur/Publications/2015/Katha_2/Data_R/totalData.csvfile_pos", sep=";", dec=",")[-25,]
abbau <- read.csv("~/Literatur/Publications/2015/Katha_2/Data_R/totalData.csv", sep=";", dec=",")[-25,]# omit U32 does not fulfill
grad <- read.csv("~/Literatur/Publications/2015/Katha_2/Data_R/Type_PCA.csv", sep=";", dec=",")[-25,]# omit U32
abbau
cor(abbau$pH, abbau$NO2)
cor(abbau$pH, abbau$NO3)
cor(abbau$DD_mi, abbau$NO3)
cor(abbau$DD_mi, abbau$NO2)
cor(abbau$DD_mi, abbau$NH3)
cor(abbau$DD_mi, abbau$NH4)
cor(abbau$DD_mi, abbau$pH)
plot(abbau$DD_mi, abbau$pH)
plot(abbau$DD_mi, abbau$NO3)
plot(abbau$DD_mi, log10(abbau$NO3))
cor(abbau$DD_mi, abbau$Org_mud)
plot(abbau$DD_mi, abbau$Org_mud)
plot(log10(abbau$NO3), abbau$DD_mi)
t.test(abbau$DD_mi[log10(abbau$NO3)< 1], abbau$DD_mi[log10(abbau$NO3)> 1])
boxplot(abbau$DD_mi[log10(abbau$NO3)< 1], abbau$DD_mi[log10(abbau$NO3)> 1]))
boxplot(abbau$DD_mi[log10(abbau$NO3)< 1], abbau$DD_mi[log10(abbau$NO3)> 1])
plot(abbau$DD, log10(abbau$NO3))
plot(log10(abbau$NO3),abbau$DD)
t.test(abbau$DD[log10(abbau$NO3)< 1], abbau$DD[log10(abbau$NO3)> 1])
55*40*20
quit()
data(stackloss)
stackloss
data(airquality)
airquality
data()
data(environmental)
environmental
data(sipoo)
sipoo
data(package = .packages(all.available = TRUE))
data(aviurba)
aviurba
data(bordeaux)
bordeaux
data(irishdata)
irishdata
?meau
data(mite)
data(mite.env)
?mite.env
mite
mite.env
library(ade49)
meau
cor(meau$env)
meau$design
library(ade4)
data(meau)
str(meau)
30/32
str(data)
str(data, list.len=150)
as.numeric(data$pH)
data$pH
data <- read.csv("~/Desktop/Data_analysis/Data Mosquito control survey.csv", sep=";", dec=",")
str(data, list.len=250)
summary(data)
head(data)
head(data, n=2ß)
head(data, n=20)
unique(data[,1:2])
sort(unique(data[,1:2]))
sort(unique(data[,1:2])[2])
sort(unique(data[,1:2])[,2])
order(unique(data[,1:2]))
56*8
26/40
library(GUTS)
vignette(package="GUTS")
str(go1)
data("diazinon")
diazinon
str(diazinon)
plot(diazinon$C1, diazinon$Ct1)
plot(diazinon$Ct1, diazinon$C1, xlab= "time", xlab="conc")
plot(diazinon$y1, diazinon$yt1, ylab= "time", xlab="survival")
plot( diazinon$yt1, diazinon$y1,ylab= "time", xlab="survival")
plot(diazinon$Ct1, diazinon$C1, ylab= "time", xlab="conc")
plot(diazinon$Ct1, diazinon$C1, xlab= "time", ylab="conc")
plot( diazinon$yt1, diazinon$y1, xlab= "time", ylab="survival")
go1 <- new("Rcpp_GUTS")
go1$setConcentrations(C = diazinon$C1, Ct = diazinon$Ct1)
go1$setSurvivors(y = diazinon$y1, yt = diazinon$yt1)
go1$setParameters(par = c(0.05084761, 0.12641525, 1.61840054, 19.09911, 6.495246))
go1$setTimeGridPoints(M = 10000)
go1$setDistribution(dist = "lognormal")
go1$setTimeGridPoints(M = 100)
go1$setSampleLength(N = 100)
go1$calcLoglikelihood()
go1$LL
go1
1065.17*2*4
1065.17*2*6
560.61*6
8522+12783+3364
65400*3
20*15
15/17
apropos("odf")
library(odfWeave)
library(ade4)#
data(meau)#
##################################################
# 1) Are communities differ between the seasons?#
##################################################
# look at data structure#
str(meau)#
# extract data sets of interest#
data <- data.frame(meau$spe,meau$design)#
head (data)
spring <- new_data$Brh[c(1:6)]#
summer <- new_data$Brh[c(7:12)]#
autumn <- new_data$Brh[c(13:18)]#
winter <- new_data$Brh[c(19:24)]#
mean <- c(mean(spring), mean(summer), mean(autumn), mean(winter))#
group <- c("spring", "summer", "autumn", "winter")#
Q2 <- data.frame(mean, group)#
summary(aov(mean ~ group, data = Q2))
1.29*8
a <- c(1390132, 73139, 108533, 16203)
b <- c(1000, 100, 100, 10 )
lm( b ~ a -1)
11316/3521
1/(11316/3521)
3000/250
21*5*11
1065.17*2
12783/4
3196+12783
12783/2+ 12783
15979+2131*2+19175
3*65,400
2.75*65400
3*65400
179850+32700
23300+2970+10050+7650
5550+3520
17.5+22.2*2
17.5+2.22*2
6840+13640+1710
35.5/40*100
134.7+13.5+122.4+3.9+13.5+208.1+22.5+59.5
trait <- matrix(data = c(30,40,30,20,80,0), nrow=2,byrow=T)
species <- matrix(data = c(3,4,1,2), nrow=2,byrow=T)
trait%*%species
trait * species
trait %*% species
species %*% trait
2.8/5
10*1.05^20
sample(1:6,2)
76*7
library(abind)
update.packages()
library(mda)
library(mnormt)
hund hund hund hund hund hund
hund hund hund
library(drc)
?drm
getMeanFunctions()
?BC.5
227/661
barplot(c(502,159))
barplot(c(502,159), labels=c("Geochemical", "Ecological"))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"))
par(cex=1.5, las=1)#
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies")
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("blue", "green"))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("blue", "green"), ylab= c(0,600))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("blue", "green"), ylim= c(0,600))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("blue", "green"), ylim= c(0,550))
counts <- table(mtcars$vs, mtcars$gear)
counts
typeof(counts)
class(counts)
dat <- data.frame(Geochemical = c(186, 502-186), Ecological = c(41, 159-41))
dat
barplot(dat)
barplot(matrix(dat))
barplot(as.matrix(dat))
barplot(as.matrix(dat)), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("white", "red"), ylim= c(0,550))
barplot(as.matrix(dat), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("white", "red"), ylim= c(0,550))
legend()
text(1,300, "polluted")
text(0.5,300, "antrhopogenically \n influenced")
text(0.7,300, "antrhopogenically \n influenced")
barplot(as.matrix(dat), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("white", "red"), ylim= c(0,550))#
text(0.7,300, "antrhopogenically \n influenced")
text(0.7,300, "anthropogenically \n influenced")
text(1.117,100, "anthropogenically \n influenced")
text(1.7,100, "anthropogenically \n influenced")
text(1.9,100, "anthropogenically \n influenced")
barplot(as.matrix(dat), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("white", "red"), ylim= c(0,550))#
text(0.7,300, "anthropogenically \n influenced")#
text(1.9,100, "anthropogenically \n influenced")
barplot(as.matrix(dat), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("red", "white"), ylim= c(0,550))#
text(0.7,300, "relatively \n pristine")#
text(1.9,100, "relatively \n pristine")
barplot(as.matrix(dat), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("grey", "white"), ylim= c(0,550))#
text(0.7,300, "relatively \n pristine")#
text(1.9,100, "relatively \n pristine")
par(cex=1.5, las=1)#
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("blue", "green"), ylim= c(0,550))
barplot(c(502,159), names.arg=c("Geochemical", "Ecological"), ylab = "# of studies", col = c("black", "black"), ylim= c(0,550))
158/(158+64+7)
64/(158+64+7)
.Platform()
get_os <- function(){#
  sysinf <- Sys.info()#
  if (!is.null(sysinf)){#
    os <- sysinf['sysname']#
    if (os == 'Darwin')#
      os <- "osx"#
  } else { ## mystery machine#
    os <- .Platform$OS.type#
    if (grepl("^darwin", R.version$os))#
      os <- "osx"#
    if (grepl("linux-gnu", R.version$os))#
      os <- "linux"#
  }#
  tolower(os)#
}
get_os()
1570000+350000+80000
2/2.023
2510000+1300000+670000
4480000/5200000
library(swirl)
swirl()
# generate some data form Normal#
mus <- c(10, 15, 20)#
sd <- 1#
n <- 5#
set.seed(0815)#
y <- unlist(lapply(mus, function(y) rnorm(n, y, sd)))#
df <- data.frame(fac = gl(3, n), y)#
### ----------
plot(df)
mod<-lm(y ~ fac, data = df)#
plot(df$fac, resid(mod))
hist(resid(mod))
require(DAAG)#
qreference(resid(mod))
dfs <- c(1,2, 4, 6, 8, 16, 32, 64, 128)#
for(i in seq_along(dfs)){#
 print(i)#
 set.seed(1)#
 qreference(rt(200, df = dfs[i]), xlab= paste0('df = ',#
as.character(dfs[i])))#
 cat("Press Enter for next plot")#
 scan(nmax=1, quiet = TRUE)#
}
dfs <- c(1,2, 4, 6, 8, 16, 32, 64, 128)#
for(i in seq_along(dfs)){#
 print(i)#
 set.seed(1)#
 qreference(rt(20, df = dfs[i]), xlab= paste0('df = ',#
as.character(dfs[i])))#
 cat("Press Enter for next plot")#
 scan(nmax=1, quiet = TRUE)#
}
sample(1:4, 4)
library(digitize)
e
exp
exp(1)
exp(1)^(0.634*4.5/(5.7e-8 * 5.5)
)
0.634*4.5/(5.7e-8 * 5.5)
citation(package="vegan")
p.adjusted(c(0.1,0.2,0.3,0.05), method="holm")
p.adjust(c(0.1,0.2,0.3,0.05), method="holm")
p.adjust(c(0.05,0.1,0.3,0.05), method="holm")
library(vegan)
data(iris)
head(iris)
iris
3/19
8/19
7/19
1/19
6/19
0.16^0.75
pfad = "~/Desktop/"
setwd(pfad)
k <- read.table("k.csv", header = TRUE, sep = ',')
str(k)
k$Gammariden <- factor(gsub(' ', '', k$Gammariden))#
# die Nummer des runs (Laubset) als Faktor definieren#
k$Laubset <- factor(k$Laubset)#
# Konzentrationen / Treatments in richtige Reihenfolge#
k$treatment <- factor(k$treatment, levels = c("control", "TU-3", "TU-2", "TU-1"))#
unique(k$treatment)
k_all <- k#
mod3_all <- aov(k ~ Gammariden + treatment + Laubset +#
              Gammariden:treatment  + treatment:Laubset,#
            data = k_all)
summary(mod3_all)
summary.lm(mod3_all)
k <- k[k$treatment %in% c('control', 'TU-1'), ]
require(ggplot2)#
ggplot(k, aes(x = treatment, fill = Gammariden, y = k)) +#
  geom_boxplot() +#
  facet_grid(~Laubset)
mod1 <- aov(k ~ Gammariden*treatment*Laubset, data = k)#
#  Gammariden*treatment = Gammariden + treatment + Gammariden:treatment#
summary(mod1)#
summary.lm(mod1)#
drop1(mod1, test = 'F')
mod2 <- aov(k ~ Gammariden + treatment + Laubset +#
              Gammariden:treatment + Gammariden:Laubset + treatment:Laubset,#
            data = k)#
summary(mod2)#
summary.lm(mod2)#
drop1(mod2, test = 'F')
mod3 <- aov(k ~ Gammariden + treatment + Laubset +#
              Gammariden:treatment  + treatment:Laubset,#
            data = k)#
drop1(mod3, test = 'F')
k_gamm <- k_all[!k_all$Gammariden == "nein",]#
ggplot(k_all, aes(x = treatment, y = k)) +#
  geom_boxplot() +#
  facet_grid(~Laubset)
mod2_gamm <- aov(k ~ treatment + Laubset +#
                   treatment:Laubset,#
                 data = k_gamm)#
summary(mod2_gamm)#
summary.lm(mod2_gamm)#
drop1(mod2_gamm, test = 'F')
require(multcomp)#
#Dunnett Test Laubset 1 mit Gammariden#
k_run_1_mit <- k_gamm[k_gamm$Laubset==1,]#
k_run_1_mit$tway <- with(k_run_1_mit, interaction(Laubset, treatment))#
mod_tw <- lm(k ~ tway - 1, data = k_run_1_mit)#
summary(mod_tw)#
summary(glht(mod_tw, linfct = mcp(tway ='Dunnett')))
k_run_2_mit <- k_gamm[k_gamm$Laubset==2,]#
k_run_2_mit$tway <- with(k_run_2_mit, interaction(Laubset, treatment))#
mod_tw <- lm(k ~ tway - 1, data = k_run_2_mit)#
summary(mod_tw)#
summary(glht(mod_tw, linfct = mcp(tway ='Dunnett')))
k_run_3_mit <- k_gamm[k_gamm$Laubset==3,]#
k_run_3_mit$tway <- with(k_run_3_mit, interaction(Laubset, treatment))#
mod_tw <- lm(k ~ tway - 1, data = k_run_3_mit)#
summary(mod_tw)#
summary(glht(mod_tw, linfct = mcp(tway ='Dunnett')))
library( 'GUTS' )      # GUTS package#
library( 'adaptMCMC' ) # function `MCMC()`, Monte Carlo Markov Chain#
library( 'dfoptim' )   # function `hjkb()`, optimiser#
library( 'grid' )      # use in function `ga_multiplot()`, part of R#
library( 'ggplot2' )   # plotting facilities#
library( 'GGally' )    # templates and helpers for ggplot2
ga_read_list <- function( file, headsep = ':', ... ) {#
	ret <- list()#
	inl <- scan(file, what = "", sep = "\n", comment.char = "#", ...)#
	nms <- NULL#
	for ( i in seq_along(inl) ) {#
		gsub(" ", "", inl[i], fixed = TRUE)#
		x <- unlist(strsplit(inl[i], ":"))#
		nms <- c(nms, x[1])#
		ret[[i]] <- as.numeric(unlist(strsplit(x[2], ",")))#
	}#
	names(ret) <- nms#
	invisible(return(ret))#
}
ga_multiplot <- function( ..., plotlist = NULL, cols ) {#
	require("grid")#
	plots <- c(list(...), plotlist)#
	numPlots <- length(plots)#
	plotCols <- cols#
	plotRows <- ceiling(numPlots/plotCols)#
	grid.newpage()#
	pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))#
	vplayout <- function(x, y) {#
		viewport(layout.pos.row = x, layout.pos.col = y)#
	}#
	for (i in 1:numPlots) {#
		curRow <- ceiling(i/plotCols)#
		curCol <- (i - 1)%%plotCols + 1#
		print(plots[[i]], vp = vplayout(curRow, curCol))#
	}#
}
ga_plot_chains <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 50 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- data.frame(i, data[i, ])#
	colnames(pdat) <- c('iter', pnms)#
	plts <- list()#
	for ( pnm in pnms ) {#
		plts[[pnm]] <- ggplot(pdat, aes_string(x='iter', y=pnm)) + geom_line() + xlab("Iteration") + ylab(paste("Parameter", pnm))#
	}#
	invisible(return(plts))#
}
ga_plot_correlations <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 1 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- as.data.frame(data[i, ])#
	colnames(pdat) <- pnms#
	plt <- ggpairs(pdat, alpha = 0.4, columnLabels = pnms)#
	invisible(return(plt))#
}
ga_tab_quantiles <- function( data, log.p, parnames = NULL, from = steps, to = nrow(data), steps = 1, p.quant = 0.025 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	maxpost <- data[which.max(log.p), ]#
	parsamp <- data[seq(from, to, steps), ]#
	quantis <- c(0 + p.quant, 0.5, 1 - p.quant)#
	parquan <- t(apply( parsamp, 2, function(x) quantile(x, probs = quantis) ))#
	ret <- matrix(c(maxpost, parquan), nrow = length(pnms), byrow = FALSE, dimnames = list( c(pnms), c('maxpost', paste('q', quantis, sep='')) ))#
	return(ret)#
}
ga_plot_densities <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 1, p.quant = 0.025 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- as.data.frame(data[i, ])#
	colnames(pdat) <- pnms#
	plts <- list()#
	datd <- data.frame()#
	for ( pnm in pnms ) {#
		quan <- quantile(pdat[, pnm], probs = c(0 + p.quant, 0.5, 1 - p.quant))#
		qua1 <- quan[1]#
		qua5 <- quan[2]#
		qua9 <- quan[3]#
		densi <- density(pdat[, pnm])#
		dxpos <- densi$x[which.max(densi$y)]#
		dypos <- max(densi$y) + max(densi$y)/20#
		dyhei <- dypos/20#
		plts[[pnm]] <- ggplot(pdat) +#
			geom_point(aes_string(x=qua5, y=dypos), data=datd) + #
			geom_errorbarh(aes_string(x=dxpos, xmin=qua1, xmax=qua9, y=dypos, height=dyhei), data=datd) +#
			geom_density(aes_string(x=pnm)) +#
			xlab(pnm) + ylab("Density")#
	}#
	invisible(return(plts))#
}
ga_tab_predictions <- function( gobjs, data, measured = FALSE, sample_size = 2000, p.quant = 0.025 ) {#
	if ( !is.list(gobjs) | length(gobjs) < 1 ) {#
		stop("Argument `gobjs` must be a list of GUTS objects.")#
	}#
	probs <- c(0, 0.5, 1) + c(p.quant, 0, -p.quant)#
	qnames <- paste('q', probs, sep='')#
	stp <- floor(nrow(data) / sample_size)#
	stopifnot(!is.na(stp), stp > 0, stp <= nrow(data))#
	i <- seq(from = stp, by = stp, length.out = sample_size)#
	psub <- data[i, ]#
	tabs <- list()#
	for ( i in 1:length(gobjs) ) {#
		S <- t(apply(psub, 1, function(x) guts_calc_survivalprobs(gobjs[[i]], x)))#
		S_d <- t(apply(S, 1, function(x) -diff(c(x, 0))))#
		y <- gobjs[[i]]$y#
		y_d <- -diff(y)#
		y_d_pred <- as.data.frame(t(apply(S_d, 1, function(x) t(rmultinom(1, y[1], x)))))#
		y_d_pred_quant <- t(sapply( y_d_pred, function(x) quantile(x, probs = probs) ))[-length(y), ]#
		dat <- data.frame(1:length(y_d), y_d, y_d_pred_quant)#
		colnames(dat) <- c('ytd', 'measured', qnames)#
		rownames(dat) <- NULL#
		if ( !measured ) {#
			dat <- dat[, -2]#
		}#
		tabs[[i]] <- dat#
	}#
	invisible(return(tabs))#
}
ga_plot_predictions <- function( gobjs, data, measured = FALSE, sample_size = 2000, p.quant = 0.025 ) {#
	if ( !is.list(gobjs) | length(gobjs) < 1 ) {#
		stop("Argument `gobjs` must be a list of GUTS objects.")#
	}#
	tabs <- ga_tab_predictions(gobjs, data, measured=TRUE, sample_size, p.quant)#
	plts <- list()#
	for ( i in 1:length(gobjs) ) {#
		datl <- nrow(tabs[[i]])#
		pdat <- tabs[[i]][, -2]#
		datv <- rep('predicted', datl)#
		if ( measured ) {#
			datm <- tabs[[i]][, 2]#
			datm <- data.frame(1:datl, datm, datm, datm)#
			colnames(datm) <- colnames(pdat)#
			datv <- c(rep('measured', datl), datv)#
			pdat <- rbind(datm, pdat)#
		}#
		pdat <- data.frame(datv, pdat)#
		colnames(pdat) <- c('Data', 'ytd', 'lo', 'y', 'hi')#
		if ( measured ) {#
			plts[[i]] <- ggplot(pdat, aes(x = ytd, y = y, group = Data, shape = Data, colour = Data, ymin = y-1, ymax = y+1))#
		} else {#
			plts[[i]] <- ggplot(pdat, aes(x = ytd, y = y, ymin = y-1, ymax = y+1))#
		}#
		plts[[i]] <- plts[[i]] +#
			geom_point(position = position_dodge(width = .2, height = 0)) +#
			geom_errorbar(aes(ymin = lo, ymax = hi), width = .5, position = position_dodge(width = .2, height = 0)) +#
			xlab("Survivor time intervals") + ylab("Number of deaths")#
	}#
	invisible(return(plts))#
}
data(diazinon)
guts_objects <- list(#
	guts_setup(C = diazinon[["C1"]], Ct = diazinon[["Ct1"]], y = diazinon[["y1"]], yt = diazinon[["yt1"]]),#
	guts_setup(C = diazinon[["C2"]], Ct = diazinon[["Ct2"]], y = diazinon[["y2"]], yt = diazinon[["yt2"]]),#
	guts_setup(C = diazinon[["C3"]], Ct = diazinon[["Ct3"]], y = diazinon[["y3"]], yt = diazinon[["yt3"]])#
)#
print(guts_objects[[1]])
logposterior <- function( pars ) {#
	ret <- sum(sapply( guts_objects,#
		function(x) guts_calc_loglikelihood(x, pars) ))#
	# Uncomment the following line, if logprior function defined.#
	#ret <- ret + logprior( pars )#
	return(ret)#
}
pars_lower <- rep(0, 5)#
pars_upper <- c(1, 1, 10, 40, 20)#
pars_start <- c(0.05, 0.1, 3, 20, 10)#
names(pars_start) <- c('hb', 'ke', 'kk', 'mn', 'sd')#
optim_function <- function( pars ) {#
	return( -logposterior(pars) )#
}#
optim_result <- hjkb(pars_start, optim_function, lower = pars_lower, upper = pars_upper)#
print(optim_result)
# Carlo Albert (carlo.albert@eawag.ch), Sören Vogel (soeren.vogel@posteo.ch), Roman Ashauer (roman.ashauer@york.ac.uk)#
# 2015-10-28, 2015-09-14, 2015-08-30, 2015-06-25#
# License: GPL-2#
# File: `S2 Example Script.R`#
# File encoding: UTF-8#
# Auxiliary Script for the Paper “Computationally Efficient Implementation of a Novel Algorithm for the General Unified Threshold Model of Survival (GUTS)”.#
# Required: R >= 3.1.3; internet connection for downloading R packages.#
##
###
# Load Libraries.#
# If not present on system, libraries can be installed using the command `install.packages( <Pack_Name> )`.  See `help( 'install.packages' )`, for more details and additional options.#
##
library( 'GUTS' )      # GUTS package#
library( 'adaptMCMC' ) # function `MCMC()`, Monte Carlo Markov Chain#
library( 'dfoptim' )   # function `hjkb()`, optimiser#
library( 'grid' )      # use in function `ga_multiplot()`, part of R#
library( 'ggplot2' )   # plotting facilities#
library( 'GGally' )    # templates and helpers for ggplot2#
###
# Functions, Helpers.#
##
#
# Function `ga_read_list()`.#
# Read in data in a list-like representation from a plain text file.  The data should be in the following form:#
# 	# Some comment, comments are ignored.#
# 	VarName1:23.3,45.7,...#
# 	VarName2:100.78,106.32,...#
# 	...#
# Arguments:#
# 	file: name of the text file.#
# 	headsep: separator used between header and data.#
# 	...: more options to be passed to scan().#
# Returns an R object of type list with vectors of data.#
ga_read_list <- function( file, headsep = ':', ... ) {#
	ret <- list()#
	inl <- scan(file, what = "", sep = "\n", comment.char = "#", ...)#
	nms <- NULL#
	for ( i in seq_along(inl) ) {#
		gsub(" ", "", inl[i], fixed = TRUE)#
		x <- unlist(strsplit(inl[i], ":"))#
		nms <- c(nms, x[1])#
		ret[[i]] <- as.numeric(unlist(strsplit(x[2], ",")))#
	}#
	names(ret) <- nms#
	invisible(return(ret))#
}#
#
# Function `ga_multiplot()`.#
# Put multiple plots on one page.#
# Arguments:#
# 	...: one or more single objects to plot.#
# 	plotlist: if NULL (default), ignore, else a list with objects to plot.#
# 	cols: put plots in this many columns on the page.#
# No return, but prints to the active output device (the screen or a file).#
ga_multiplot <- function( ..., plotlist = NULL, cols ) {#
	require("grid")#
	plots <- c(list(...), plotlist)#
	numPlots <- length(plots)#
	plotCols <- cols#
	plotRows <- ceiling(numPlots/plotCols)#
	grid.newpage()#
	pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))#
	vplayout <- function(x, y) {#
		viewport(layout.pos.row = x, layout.pos.col = y)#
	}#
	for (i in 1:numPlots) {#
		curRow <- ceiling(i/plotCols)#
		curCol <- (i - 1)%%plotCols + 1#
		print(plots[[i]], vp = vplayout(curRow, curCol))#
	}#
}#
#
# Function `ga_plot_chains()`.#
# Plot the parameter posterior chains from the MCMC.#
# Arguments:#
# 	data: posterior samples.#
# 	parnames: if NULL (default), take parameter names from the column names in data, else character vector of parameter names.#
# 	from: drop first `from-1` parameters from data, defaults to `steps=1`.#
# 	to: consider data until this row, defaults to `nrow(data)` (i.e., all rows).#
# 	steps: consider data at `steps` intervals, defaults to 50.#
# Returns a list of `ggplot` objects, which can be printed to an output device (the screen or a file).#
ga_plot_chains <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 50 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- data.frame(i, data[i, ])#
	colnames(pdat) <- c('iter', pnms)#
	plts <- list()#
	for ( pnm in pnms ) {#
		plts[[pnm]] <- ggplot(pdat, aes_string(x='iter', y=pnm)) + geom_line() + xlab("Iteration") + ylab(paste("Parameter", pnm))#
	}#
	invisible(return(plts))#
}#
#
# Function `ga_plot_correlations()`.#
# Plots the correlations between the posterior parameters from the MCMC.#
# Arguments:#
# 	data: posterior samples.#
# 	parnames: if NULL (default), take parameter names from the column names in data, else character vector of parameter names.#
# 	from: drop first `from-1` parameters from data, defaults to `steps=1`.#
# 	to: consider data until this row, defaults to `nrow(data)` (i.e., all rows).#
# 	steps: consider data at \verb!steps! intervals, defaults to 1 (i.e., all data).#
# Returns a list of `ggplot` objects, which can be printed to an output device (the screen or a file).  Note: file sizes of these plots can become large.#
ga_plot_correlations <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 1 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- as.data.frame(data[i, ])#
	colnames(pdat) <- pnms#
	plt <- ggpairs(pdat, alpha = 0.4, columnLabels = pnms)#
	invisible(return(plt))#
}#
#
# Function `ga_tab_quantiles()`.#
# Calculates the posterior quantiles and the parameter set that maximises the posterior.#
# Arguments:#
# 	data: posterior samples.#
# 	log.p: loglikelihood of the posterior samples.#
# 	parnames: if NULL (default), take parameter names from the column names in data, else character vector of parameter names.#
# 	from: drop first `from-1` parameters from data, defaults to `steps=1`.#
# 	to: consider data until this row, defaults to `nrow(data)` (i.e., all rows).#
# 	steps: consider data at `steps` intervals, defaults to 1 (i.e., all data).#
# 	p.quant: quantiles to use (default 0.025), `upper=1-p.quant`, `lower=0+p.quant`, 0.5 is always added.#
# Returns a R object of type `matrix` with columns for “maxpost” and “quantiles”.  Each line represents one parameter.#
ga_tab_quantiles <- function( data, log.p, parnames = NULL, from = steps, to = nrow(data), steps = 1, p.quant = 0.025 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	maxpost <- data[which.max(log.p), ]#
	parsamp <- data[seq(from, to, steps), ]#
	quantis <- c(0 + p.quant, 0.5, 1 - p.quant)#
	parquan <- t(apply( parsamp, 2, function(x) quantile(x, probs = quantis) ))#
	ret <- matrix(c(maxpost, parquan), nrow = length(pnms), byrow = FALSE, dimnames = list( c(pnms), c('maxpost', paste('q', quantis, sep='')) ))#
	return(ret)#
}#
#
# Function `ga_plot_densities()`.#
# Plots the densities of the posterior parameters from the MCMC.#
# Arguments:#
# 	data: posterior samples.#
# 	parnames: if NULL (default), take parameter names from the column names in data, else character vector of parameter names.#
# 	from: drop first `from-1` parameters from data, defaults to `steps=1`.#
# 	to: consider data until this row, defaults to `nrow(data)` (i.e., all rows).#
# 	steps: consider data at `steps` intervals, defaults to 1 (i.e., all data).#
# 	p.quant: quantiles to use (default 0.025), `upper=1-p.quant`, `lower=0+p.quant`, 0.5 is always added.#
# Returns a list of `ggplot` objects, which can be printed to an output device (the screen or a file).#
ga_plot_densities <- function( data, parnames = NULL, from = steps, to = nrow(data), steps = 1, p.quant = 0.025 ) {#
	if ( is.null(parnames) ) {#
		pnms <- colnames(data)#
	} else {#
		pnms <- parnames#
	}#
	i <- seq(from, to, steps)#
	pdat <- as.data.frame(data[i, ])#
	colnames(pdat) <- pnms#
	plts <- list()#
	datd <- data.frame()#
	for ( pnm in pnms ) {#
		quan <- quantile(pdat[, pnm], probs = c(0 + p.quant, 0.5, 1 - p.quant))#
		qua1 <- quan[1]#
		qua5 <- quan[2]#
		qua9 <- quan[3]#
		densi <- density(pdat[, pnm])#
		dxpos <- densi$x[which.max(densi$y)]#
		dypos <- max(densi$y) + max(densi$y)/20#
		dyhei <- dypos/20#
		plts[[pnm]] <- ggplot(pdat) +#
			geom_point(aes_string(x=qua5, y=dypos), data=datd) + #
			geom_errorbarh(aes_string(x=dxpos, xmin=qua1, xmax=qua9, y=dypos, height=dyhei), data=datd) +#
			geom_density(aes_string(x=pnm)) +#
			xlab(pnm) + ylab("Density")#
	}#
	invisible(return(plts))#
}#
#
# Function `ga_tab_predictions()`.#
# Calculate quantiles for the predicted survivors.#
# Arguments:#
# 	gobjs: list of GUTS objects.#
# 	data: posterior samples.#
# 	measured: if FALSE (default), do not include survivor counts in `gobjs`.#
# 	sample_size: number of realisations.#
# 	p.quant: quantiles to use, `upper=1-p.quant`, `lower=0+p.quant`, 0.5 is always added.#
# Returns a R object of type `list`.  Each list element is a data frame with the time steps, measured deaths (if `measured = TRUE`) and the quantiles of predicted deaths.#
ga_tab_predictions <- function( gobjs, data, measured = FALSE, sample_size = 2000, p.quant = 0.025 ) {#
	if ( !is.list(gobjs) | length(gobjs) < 1 ) {#
		stop("Argument `gobjs` must be a list of GUTS objects.")#
	}#
	probs <- c(0, 0.5, 1) + c(p.quant, 0, -p.quant)#
	qnames <- paste('q', probs, sep='')#
	stp <- floor(nrow(data) / sample_size)#
	stopifnot(!is.na(stp), stp > 0, stp <= nrow(data))#
	i <- seq(from = stp, by = stp, length.out = sample_size)#
	psub <- data[i, ]#
	tabs <- list()#
	for ( i in 1:length(gobjs) ) {#
		S <- t(apply(psub, 1, function(x) guts_calc_survivalprobs(gobjs[[i]], x)))#
		S_d <- t(apply(S, 1, function(x) -diff(c(x, 0))))#
		y <- gobjs[[i]]$y#
		y_d <- -diff(y)#
		y_d_pred <- as.data.frame(t(apply(S_d, 1, function(x) t(rmultinom(1, y[1], x)))))#
		y_d_pred_quant <- t(sapply( y_d_pred, function(x) quantile(x, probs = probs) ))[-length(y), ]#
		dat <- data.frame(1:length(y_d), y_d, y_d_pred_quant)#
		colnames(dat) <- c('ytd', 'measured', qnames)#
		rownames(dat) <- NULL#
		if ( !measured ) {#
			dat <- dat[, -2]#
		}#
		tabs[[i]] <- dat#
	}#
	invisible(return(tabs))#
}#
#
# Function `ga_plot_predictions()`.#
# Plot quantiles for the predicted survivors.#
# Arguments:#
# 	gobjs: list of GUTS objects.#
# 	data: posterior samples.#
# 	measured: if FALSE (default), do not include survivor counts in `gobjs`.#
# 	sample_size: number of realisations.#
# 	p.quant: quantiles to use, `upper=1-p.quant`, `lower=0+p.quant`, 0.5 is always added.#
# Returns a list of `ggplot` objects, which can be printed to an output device (the screen or a file).#
ga_plot_predictions <- function( gobjs, data, measured = FALSE, sample_size = 2000, p.quant = 0.025 ) {#
	if ( !is.list(gobjs) | length(gobjs) < 1 ) {#
		stop("Argument `gobjs` must be a list of GUTS objects.")#
	}#
	tabs <- ga_tab_predictions(gobjs, data, measured=TRUE, sample_size, p.quant)#
	plts <- list()#
	for ( i in 1:length(gobjs) ) {#
		datl <- nrow(tabs[[i]])#
		pdat <- tabs[[i]][, -2]#
		datv <- rep('predicted', datl)#
		if ( measured ) {#
			datm <- tabs[[i]][, 2]#
			datm <- data.frame(1:datl, datm, datm, datm)#
			colnames(datm) <- colnames(pdat)#
			datv <- c(rep('measured', datl), datv)#
			pdat <- rbind(datm, pdat)#
		}#
		pdat <- data.frame(datv, pdat)#
		colnames(pdat) <- c('Data', 'ytd', 'lo', 'y', 'hi')#
		if ( measured ) {#
			plts[[i]] <- ggplot(pdat, aes(x = ytd, y = y, group = Data, shape = Data, colour = Data, ymin = y-1, ymax = y+1))#
		} else {#
			plts[[i]] <- ggplot(pdat, aes(x = ytd, y = y, ymin = y-1, ymax = y+1))#
		}#
		plts[[i]] <- plts[[i]] +#
			geom_point(position = position_dodge(width = .2, height = 0)) +#
			geom_errorbar(aes(ymin = lo, ymax = hi), width = .5, position = position_dodge(width = .2, height = 0)) +#
			xlab("Survivor time intervals") + ylab("Number of deaths")#
	}#
	invisible(return(plts))#
}#
###
# Load GUTS Data, set up Guts Objects, inspect objects.#
##
data(diazinon)#
#
# Uncomment if inspecting the data set:#
#str(diazinon)#
#
guts_objects <- list(#
	guts_setup(C = diazinon[["C1"]], Ct = diazinon[["Ct1"]], y = diazinon[["y1"]], yt = diazinon[["yt1"]]),#
	guts_setup(C = diazinon[["C2"]], Ct = diazinon[["Ct2"]], y = diazinon[["y2"]], yt = diazinon[["yt2"]]),#
	guts_setup(C = diazinon[["C3"]], Ct = diazinon[["Ct3"]], y = diazinon[["y3"]], yt = diazinon[["yt3"]])#
)#
print(guts_objects[[1]])#
###
# (Logprior and) Logposterior Function.#
# For use in optimiser and MCMC.#
##
#
# Possible logprior definition#
#logprior <- function( x ) {#
#	#do something and return logprior#
#}#
#
# Logposterior definition#
logposterior <- function( pars ) {#
	ret <- sum(sapply( guts_objects,#
		function(x) guts_calc_loglikelihood(x, pars) ))#
	# Uncomment the following line, if logprior function defined.#
	#ret <- ret + logprior( pars )#
	return(ret)#
}#
###
# Optimisation, Start Parameters, Inspect Results.#
##
pars_lower <- rep(0, 5)#
pars_upper <- c(1, 1, 10, 40, 20)#
pars_start <- c(0.05, 0.1, 3, 20, 10)#
names(pars_start) <- c('hb', 'ke', 'kk', 'mn', 'sd')#
optim_function <- function( pars ) {#
	return( -logposterior(pars) )#
}#
optim_result <- hjkb(pars_start, optim_function, lower = pars_lower, upper = pars_upper)
optim_result <- hjkb(pars = pars_start, fn = optim_function, lower = pars_lower, upper = pars_upper)
optim_result <- hjkb(par = pars_start, fn = optim_function, lower = pars_lower, upper = pars_upper)
library(FD)
library(vegan)#
data(mite)#
data("mite.env")#
str(mite)#
str(mite.env)#
## Part a) ## #
qqnorm(mite.env$WatrCont) # normally distributed #
boxplot(WatrCont~Shrub, data = mite.env) # homoscedastic #
# so we can use parametric methods #
mite_anova<-aov(WatrCont~Shrub, data = mite.env)#
summary(mite_anova)#
# results  are statistically highly significant (p < 0.001)#
library(multcomp)#
mite_multcomp <- glht(mite_anova, linfct=mcp(Shrub="Tukey"))#
summary(mite_multcomp)
mite_model_1 <- lm(WatrCont~SubsDens, data = mite.env)#
par(mfrow=c(1,3))#
plot(mite_model_1, which = 1:3)#
plot(mite_model_1, which = 4:6)
cirt.hat <- 2*(5/nrow(mite.env)) # 8th value is an outlier
mite.env2 <- mite.env[-8,]#
mite_model_2 <- lm(WatrCont~SubsDens, data = mite.env2)
par(mfrow=c(1,3))#
plot(mite_model_2, which = 1:3)#
plot(mite_model_2, which = 4:6)
library(car)#
crPlots(mite_model_2) ## a l
summary.lm(mite_model_1)
library(mvoutlier)#
library(vegan)#
library(BiodiversityR)#
library(chemometrics)#
par(mfrow=c(1,1))#
chisq.plot(mite, quan = 1, ask = F)
mite_pa <- decostand(mite,"pa")#
apply(mite_pa,2,sum) # no rare species #
sort(apply(mite_pa,2,sd)) # ne
mite_pca <- rda(mite, scale =T)#
mite_pca2 <- princomp(mite,cor=T)
summary(mite)
mite_pca <- rda(mite, scale =T)#
mite_pca2 <- princomp(mite,cor=T)#
res <- pcaDiagplot(mite,mite_pca2)
chisq.plot(sqrt(mite), quan = 1, ask = F)
chisq.plot(log10(mite), quan = 1, ask = F)
log10(mite)
chisq.plot((mite)^0.25, quan = 1, ask = F)
sum(res$ODist>res$critOD & res$SDist > res$critSD) # no oultiers
summary(mite_pca, display = NULL)
summary(mite_pca)$cont$importance[3,] > 0.8 # sum criterion argues that 13 axes should be used #
ev <- mite_pca$CA$eig#
ev[ev>mean(ev)]   # the eigenvalues of the first ten axes are bigger then the mean #
screeplot(mite_pca, bstick = T)#
PCAsignificance(mite_pca) ##broken stick and screeplot wsuggest only using the first axis
par(mfrow=c(1,1))#
mite_mds <- metaMDS(mite)#
stressplot(mite_mds)
plot(mite_mds, type = "n")#
orditorp(mite_mds, display ="sites")#
ef <- envfit (mite_mds, mite.env, permutations = 500)#
plot(ef, p.max = 0.05, axis =T)
setwd("~/Downloads/")#
library(raster)#
sand <- raster("~/Downloads/geonode_sndppt_m_sl1_250m.tif")
image(sand)
spplot(sand)
sand@crs
readRDS("~/Arbeit/Lehre_Betreuung/2016/SS/Summer_academy/Modelling/Rainfall/GADM_2.8_MWI_adm0.rds")
maw_gadm <- readRDS("~/Arbeit/Lehre_Betreuung/2016/SS/Summer_academy/Modelling/Rainfall/GADM_2.8_MWI_adm0.rds")
ls()
sub <- crop(sand, extent(maw_gadm))
maw_gadm@proj4
str(maw_gadm@proj4)
str(maw_gadm)
maw_gadm@proj4string
sub <- crop(sand, maw_gadm)
spplot(sub)
library(raster)
sand <- raster("~/Downloads/geonode_sndppt_m_sl1_250m.tif")
setwd("~/Arbeit/Lehre_Betreuung/2016/SS/Summer_academy/Modelling/Soil_grids")
sand <- raster("geonode_sndppt_m_sl1_250m.tif")
silt <- raster("geonode_sltppt_m_sl1_250m.tif")
identical(maw_gadm@proj4string, sand@crs)
sub <- mask(sand, maw_gadm)
sand_sub1 <- crop(sand, maw_gadm)
sand_sub2 <- mask(sand_sub1, maw_gadm)
sum(sand_sub2 >= 50)
spplot(sand_sub2)
sand_sub2@values
sand_sub2 > 50
?cellStats
cellStats(sand_sub2)
cellStats(sand_sub2, stat="mean")
hist(sand_sub2)
hist(sand_sub2, las=1)
hist(sand_sub2, las=1, dens=TRUE)
hist(sand_sub2, las=1, freq=FALSE )
par(las=1,cex=1.5)
hist(sand_sub2, las=1, freq=FALSE, cex=1.5 )
hist(sand_sub2, freq=FALSE, xlab="%Sand content", main="")
silt_sub1 <- crop(silt, maw_gadm)#
# mask values outside of Malawi#
silt_sub2 <- mask(silt_sub1, maw_gadm)#
spplot(silt_sub2)
